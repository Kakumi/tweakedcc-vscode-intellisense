import * as vscode from "vscode";
import BaseModule from "./base.module";
import { Method } from "../interfaces/method";

export default class shellModule extends BaseModule {
  constructor() {
    super(`shell`, `The shell API provides access to CraftOS's command line interface.`);
  }

  protected getMethods(): Method[] {
    return [{"label":"execute","detail":"execute(command: string, ... string Arguments to this program.): boolean","parameters":["command: string","... string Arguments to this program."],"documentation":"Run a program with the supplied arguments.\n\n**Parameters:**\n- **command: string** The program to execute.\n- ... string Arguments to this program.\n\n**Returns:**\n- boolean Whether the program exited successfully.\n\n**Usage:**\n\nRun paint my-image from within your program:\n\n```\n\nshell.execute(\"paint\", \"my-image\")\n\n```"},{"label":"run","detail":"run(... string The program to run and its arguments.): boolean","parameters":["... string The program to run and its arguments."],"documentation":"Run a program with the supplied arguments.\n\n**Parameters:**\n- ... string The program to run and its arguments.\n\n**Returns:**\n- boolean Whether the program exited successfully.\n\n**Usage:**\n\nRun paint my-image from within your program:\n\n```\n\nshell.run(\"paint\", \"my-image\")\n\n```"},{"label":"exit","detail":"exit(): void","parameters":[],"documentation":"Exit the current shell."},{"label":"dir","detail":"dir(): string","parameters":[],"documentation":"Return the current working directory. This is what is displayed before the\n>  of the shell prompt, and is used by shell.resolve to handle relative\npaths.\n\n**Returns:**\n- string The current working directory."},{"label":"setDir","detail":"setDir(dir: string): void","parameters":["dir: string"],"documentation":"Set the current working directory.\n\n**Parameters:**\n- **dir: string** The new working directory.\n\n**Usage:**\n\nSet the working directory to \"rom\"\n\n```\n\nshell.setDir(\"rom\")\n\n```"},{"label":"path","detail":"path(): string","parameters":[],"documentation":"Set the path where programs are located.\n\n**Returns:**\n- string The current shell's path."},{"label":"setPath","detail":"setPath(path: string): void","parameters":["path: string"],"documentation":"Set the current program path.\n\n**Parameters:**\n- **path: string** The new program path."},{"label":"resolve","detail":"resolve(path: string): void","parameters":["path: string"],"documentation":"Resolve a relative path to an absolute path.\n\n**Parameters:**\n- **path: string** The path to resolve.\n\n**Usage:**\n\nResolve startup.lua when in the rom folder.\n\n```\n\nshell.setDir(\"rom\")\n\nprint(shell.resolve(\"startup.lua\"))\n\n-- => rom/startup.lua\n\n```"},{"label":"resolveProgram","detail":"resolveProgram(command: string): string | not","parameters":["command: string"],"documentation":"Resolve a program, using the program path and list of aliases.\n\n**Parameters:**\n- **command: string** The name of the program\n\n**Returns:**\n- string | nil The absolute path to the program, or nil if it could\n- not be found.\n\n**Usage:**\n\nLocate the hello program.\n\n```\n\n shell.resolveProgram(\"hello\")\n\n -- => rom/programs/fun/hello.lua\n\n```"},{"label":"programs","detail":"programs(include_hidden?: boolean): {","parameters":["include_hidden?: boolean"],"documentation":"Return a list of all programs on the path.\n\n**Parameters:**\n- **include_hidden?: boolean** Include hidden files. Namely, any which\nstart with ..\n\n**Returns:**\n- { string } A list of available programs.\n\n**Usage:**\n\ntextutils.tabulate(shell.programs())"},{"label":"complete","detail":"complete(sLine: string): {","parameters":["sLine: string"],"documentation":"Complete a shell command line.\n\n**Parameters:**\n- **sLine: string** The input to complete.\n\n**Returns:**\n- { string } | nil The list of possible completions."},{"label":"completeProgram","detail":"completeProgram(program: string): {","parameters":["program: string"],"documentation":"Complete the name of a program.\n\n**Parameters:**\n- **program: string** The name of a program to complete.\n\n**Returns:**\n- { string } A list of possible completions."},{"label":"setCompletionFunction","detail":"setCompletionFunction(program: string, complete: function): void","parameters":["program: string","complete: function"],"documentation":"Set the completion function for a program. When the program is entered on\nthe command line, this program will be called to provide auto-complete\ninformation.\n\n**Parameters:**\n- **program: string** The path to the program. This should be an absolute path\nwithout the leading /.\n- **complete: function**(shell: table, index: number, argument: string, previous: { string }):{ string } | nil The completion function."},{"label":"getCompletionInfo","detail":"getCompletionInfo(): { | absolute","parameters":[],"documentation":"Get a table containing all completion functions.\n\n**Returns:**\n- { [string] = { fnComplete = function } } A table mapping the\n- absolute path of programs, to their completion functions."},{"label":"getRunningProgram","detail":"getRunningProgram(): string","parameters":[],"documentation":"Returns the path to the currently running program.\n\n**Returns:**\n- string The absolute path to the running program."},{"label":"setAlias","detail":"setAlias(command: string, program: string): void","parameters":["command: string","program: string"],"documentation":"Add an alias for a program.\n\n**Parameters:**\n- **command: string** The name of the alias to add.\n- **program: string** The name or path to the program.\n\n**Usage:**\n\nAlias vim to the edit program\n\n```\n\nshell.setAlias(\"vim\", \"edit\")\n\n```"},{"label":"clearAlias","detail":"clearAlias(command: string): void","parameters":["command: string"],"documentation":"Remove an alias.\n\n**Parameters:**\n- **command: string** The alias name to remove."},{"label":"aliases","detail":"aliases(): { | aliases,","parameters":[],"documentation":"Get the current aliases for this shell.\n\n**Returns:**\n- { [string] = string } A table, where the keys are the names of\n- aliases, and the values are the path to the program."},{"label":"openTab","detail":"openTab(... string The command line to run.): void","parameters":["... string The command line to run."],"documentation":"Open a new multishell tab running a command.\n\n**Parameters:**\n- ... string The command line to run.\n\n**Usage:**\n\nLaunch the Lua interpreter and switch to it.\n\n```\n\nlocal id = shell.openTab(\"lua\")\n\nshell.switchTab(id)\n\n```"},{"label":"switchTab","detail":"switchTab(id: number): void","parameters":["id: number"],"documentation":"Switch to the multishell tab with the given index.\n\n**Parameters:**\n- **id: number** The tab to switch to."}];
  }
}
