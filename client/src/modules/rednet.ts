import * as vscode from "vscode";
import BaseModule from "./base.module";
import { Method } from "../interfaces/method";

export default class rednetModule extends BaseModule {
  constructor() {
    super(`rednet`, `Communicate with other computers by using modems. rednetprovides a layer of abstraction on top of the main modem peripheral, making
it slightly easier to use.`);
  }

  protected getMethods(): Method[] {
    return [{"label":"CHANNEL_BROADCAST","detail":"CHANNEL_BROADCAST(): void","parameters":[],"documentation":"The channel used by the Rednet API to broadcast messages."},{"label":"CHANNEL_REPEAT","detail":"CHANNEL_REPEAT(): void","parameters":[],"documentation":"The channel used by the Rednet API to repeat messages."},{"label":"MAX_ID_CHANNELS","detail":"MAX_ID_CHANNELS(): void","parameters":[],"documentation":"The number of channels rednet reserves for computer IDs. Computers with IDs\ngreater or equal to this limit wrap around to 0."},{"label":"open","detail":"open(modem: string): void","parameters":["modem: string"],"documentation":"Opens a modem with the given peripheral name, allowing it to send and\nreceive messages over rednet.\n\n**Parameters:**\n- **modem: string** The name of the modem to open.\n\n**Usage:**\n\nOpen rednet on the back of the computer, allowing you to send and receive\n\n```\n\nrednet messages using it.\n\nrednet.open(\"back\")\n\nOpen rednet on all attached modems. This abuses the \"filter\" argument to\n\nperipheral.find.\n\nperipheral.find(\"modem\", rednet.open)\n\n```"},{"label":"close","detail":"close(modem?: string): void","parameters":["modem?: string"],"documentation":"Close a modem with the given peripheral name, meaning it can no longer\nsend and receive rednet messages.\n\n**Parameters:**\n- **modem?: string** The side the modem exists on. If not given, all\nopen modems will be closed."},{"label":"isOpen","detail":"isOpen(modem?: string): boolean","parameters":["modem?: string"],"documentation":"Determine if rednet is currently open.\n\n**Parameters:**\n- **modem?: string** Which modem to check. If not given, all connected\nmodems will be checked.\n\n**Returns:**\n- boolean If the given modem is open."},{"label":"send","detail":"send(recipient: number, message  The message to send. Like with modem.transmit, this can\ncontain any primitive type (numbers, booleans and strings) as well as\ntables. Other types (like functions), as well as metatables, will not be\ntransmitted., protocol?: string): boolean | currently | actually","parameters":["recipient: number","message  The message to send. Like with modem.transmit, this can\ncontain any primitive type (numbers, booleans and strings) as well as\ntables. Other types (like functions), as well as metatables, will not be\ntransmitted.","protocol?: string"],"documentation":"Allows a computer or turtle with an attached modem to send a message\nintended for a computer with a specific ID. At least one such modem must first\nbe opened before sending is possible.\n\n**Parameters:**\n- **recipient: number** The ID of the receiving computer.\n- message  The message to send. Like with modem.transmit, this can\ncontain any primitive type (numbers, booleans and strings) as well as\ntables. Other types (like functions), as well as metatables, will not be\ntransmitted.\n- **protocol?: string** The \"protocol\" to send this message under. When\nusing rednet.receive one can filter to only receive messages sent under a\nparticular protocol.\n\n**Returns:**\n- boolean If this message was successfully sent (i.e. if rednet is\n- currently open). Note, this does not guarantee the message was\n- actually received.\n\n**Usage:**\n\nSend a message to computer #2.\n\n```\n\nrednet.send(2, \"Hello from rednet!\")\n\n```"},{"label":"broadcast","detail":"broadcast(message  The message to send. This should not contain coroutines or\nfunctions, as they will be converted to nil., protocol?: string): void","parameters":["message  The message to send. This should not contain coroutines or\nfunctions, as they will be converted to nil.","protocol?: string"],"documentation":"Broadcasts a string message over the predefined CHANNEL_BROADCAST\nchannel. The message will be received by every device listening to rednet.\n\n**Parameters:**\n- message  The message to send. This should not contain coroutines or\nfunctions, as they will be converted to nil.\n- **protocol?: string** The \"protocol\" to send this message under. When\nusing rednet.receive one can filter to only receive messages sent under a\nparticular protocol.\n\n**Usage:**\n\nBroadcast the words \"Hello, world!\" to every computer using rednet.\n\n```\n\nrednet.broadcast(\"Hello, world!\")\n\n```"},{"label":"receive","detail":"receive(protocol_filter?: string, timeout?: number): number | The | string | nil","parameters":["protocol_filter?: string","timeout?: number"],"documentation":"Wait for a rednet message to be received, or until nTimeout seconds have\nelapsed.\n\n**Parameters:**\n- **protocol_filter?: string** The protocol the received message must be\nsent with. If specified, any messages not sent under this protocol will be\ndiscarded.\n- **timeout?: number** The number of seconds to wait if no message is\nreceived.\n\n**Returns:**\n- number The computer which sent this message\n- The received message\n- string | nil The protocol this message was sent under.\n- nil If the timeout elapsed and no message was received.\n\n**Usage:**\n\nReceive a rednet message.\n\n```\n\nlocal id, message = rednet.receive()\n\nprint((\"Computer %d sent message %s\"):format(id, message))\n\nReceive a message, stopping after 5 seconds if no message was received.\n\nlocal id, message = rednet.receive(nil, 5)\n\nif not id then\n\n    printError(\"No message received\")\n\nelse\n\n    print((\"Computer %d sent message %s\"):format(id, message))\n\nend\n\nReceive a message from computer #2.\n\nlocal id, message\n\nrepeat\n\n    id, message = rednet.receive()\n\nuntil id == 2\n\n\n\nprint(message)\n\n```"},{"label":"host","detail":"host(protocol: string, hostname: string): void","parameters":["protocol: string","hostname: string"],"documentation":"Register the system as \"hosting\" the desired protocol under the specified\nname. If a rednet lookup is performed for that protocol (and\nmaybe name) on the same network, the registered system will automatically\nrespond via a background process, hence providing the system performing the\nlookup with its ID number.\n\n**Parameters:**\n- **protocol: string** The protocol this computer provides.\n- **hostname: string** The name this computer exposes for the given protocol."},{"label":"unhost","detail":"unhost(protocol: string): void","parameters":["protocol: string"],"documentation":"Stop hosting a specific protocol, meaning it will no longer\nrespond to rednet.lookup requests.\n\n**Parameters:**\n- **protocol: string** The protocol to unregister your self from."},{"label":"lookup","detail":"lookup(protocol: string, hostname?: string): number... | number | or","parameters":["protocol: string","hostname?: string"],"documentation":"Search the local rednet network for systems hosting the\ndesired protocol and returns any computer IDs that respond as \"registered\"\nagainst it.\n\n**Parameters:**\n- **protocol: string** The protocol to search for.\n- **hostname?: string** The hostname to search for.\n\n**Returns:**\n- number... A list of computer IDs hosting the given protocol.\n- number | nil The computer ID with the provided hostname and protocol,\n- or nil if none exists.\n\n**Usage:**\n\nFind all computers which are hosting the \"chat\" protocol.\n\n```\n\nlocal computers = {rednet.lookup(\"chat\")}\n\nprint(#computers .. \" computers available to chat\")\n\nfor _, computer in pairs(computers) do\n\n  print(\"Computer #\" .. computer)\n\nend\n\nFind a computer hosting the \"chat\" protocol with a hostname of \"my_host\".\n\nlocal id = rednet.lookup(\"chat\", \"my_host\")\n\nif id then\n\n  print(\"Found my_host at computer #\" .. id)\n\nelse\n\n  printError(\"Cannot find my_host\")\n\nend\n\n```"},{"label":"run","detail":"run(): void","parameters":[],"documentation":"Listen for modem messages and converts them into rednet messages, which may\nthen be received."}];
  }
}
