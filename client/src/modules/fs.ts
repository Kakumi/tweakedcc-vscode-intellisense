import * as vscode from "vscode";
import BaseModule from "./base.module";
import { Method } from "../interfaces/method";

export default class fsModule extends BaseModule {
  constructor() {
    super(`fs`, `Interact with the computer's files and filesystem, allowing you to manipulate files, directories and paths. Thisincludes:`);
  }

  protected getMethods(): Method[] {
    return [{"label":"complete","detail":"complete(path: string, location: string, include_files?: boolean, include_dirs?: boolean, path: string, location: string, options { include_dirs? = boolean, include_files? = boolean, include_hidden? = boolean } This table form is an expanded version of the previous syntax. The\ninclude_files and include_dirs arguments from above are passed in as fields.\nThis table also accepts the following options:\n\ninclude_hidden: Whether to include hidden files (those starting with .)\nby default. They will still be shown when typing a .., include_hidden: Whether to include hidden files (those starting with .)\nby default. They will still be shown when typing a ..): {","parameters":["path: string","location: string","include_files?: boolean","include_dirs?: boolean","path: string","location: string","options { include_dirs? = boolean, include_files? = boolean, include_hidden? = boolean } This table form is an expanded version of the previous syntax. The\ninclude_files and include_dirs arguments from above are passed in as fields.\nThis table also accepts the following options:\n\ninclude_hidden: Whether to include hidden files (those starting with .)\nby default. They will still be shown when typing a ..","include_hidden: Whether to include hidden files (those starting with .)\nby default. They will still be shown when typing a .."],"documentation":"Provides completion for a file or directory name, suitable for use with\n_G.read.\n\n**Parameters:**\n- **path: string** The path to complete.\n- **location: string** The location where paths are resolved from.\n- **include_files?: boolean** = true When false, only directories will\nbe included in the returned list.\n- **include_dirs?: boolean** = true When false, \"raw\" directories will\nnot be included in the returned list.\n- **path: string** The path to complete.\n- **location: string** The location where paths are resolved from.\n- options { include_dirs? = boolean, include_files? = boolean, include_hidden? = boolean } This table form is an expanded version of the previous syntax. The\ninclude_files and include_dirs arguments from above are passed in as fields.\nThis table also accepts the following options:\n\ninclude_hidden: Whether to include hidden files (those starting with .)\nby default. They will still be shown when typing a ..\n- include_hidden: Whether to include hidden files (those starting with .)\nby default. They will still be shown when typing a ..\n\n**Returns:**\n- { string... } A list of possible completion candidates.\n\n**Usage:**\n\nComplete files in the root directory.\n\n```\n\nread(nil, nil, function(str)\n\n    return fs.complete(str, \"\", true, false)\n\nend)\n\nComplete files in the root directory, hiding hidden files by default.\n\nread(nil, nil, function(str)\n\n    return fs.complete(str, \"\", {\n\n        include_files = true,\n\n        include_dirs = false,\n\n        include_hidden = false,\n\n    })\n\nend)\n\n```"},{"label":"find","detail":"find(path: string): {","parameters":["path: string"],"documentation":"Searches for files matching a string with wildcards.\n\n**Parameters:**\n- **path: string** The wildcard-qualified path to search for.\n\n**Returns:**\n- { string... } A list of paths that match the search string.\n\n**Usage:**\n\nList all Markdown files in the help folder\n\n```\n\nfs.find(\"rom/help/*.md\")\n\n```"},{"label":"isDriveRoot","detail":"isDriveRoot(path: string): boolean","parameters":["path: string"],"documentation":"Returns true if a path is mounted to the parent filesystem.\n\n**Parameters:**\n- **path: string** The path to check.\n\n**Returns:**\n- boolean If the path is mounted, rather than a normal file/folder."},{"label":"list","detail":"list(path: string): {","parameters":["path: string"],"documentation":"Returns a list of files in a directory.\n\n**Parameters:**\n- **path: string** The path to list.\n\n**Returns:**\n- { string... } A table with a list of files in the directory.\n\n**Usage:**\n\nList all files under /rom/\n\n```\n\nlocal files = fs.list(\"/rom/\")\n\nfor i = 1, #files do\n\n  print(files[i])\n\nend\n\n```"},{"label":"combine","detail":"combine(path: string, ... string Additional parts of the path to combine.): string","parameters":["path: string","... string Additional parts of the path to combine."],"documentation":"Combines several parts of a path into one full path, adding separators as\nneeded.\n\n**Parameters:**\n- **path: string** The first part of the path. For example, a parent directory path.\n- ... string Additional parts of the path to combine.\n\n**Returns:**\n- string The new path, with separators added between parts as needed.\n\n**Usage:**\n\nCombine several file paths together\n\n```\n\nfs.combine(\"/rom/programs\", \"../apis\", \"parallel.lua\")\n\n-- => rom/apis/parallel.lua\n\n```"},{"label":"getName","detail":"getName(path: string): string","parameters":["path: string"],"documentation":"Returns the file name portion of a path.\n\n**Parameters:**\n- **path: string** The path to get the name from.\n\n**Returns:**\n- string The final part of the path (the file name).\n\n**Usage:**\n\nGet the file name of rom/startup.lua\n\n```\n\nfs.getName(\"rom/startup.lua\")\n\n-- => startup.lua\n\n```"},{"label":"getDir","detail":"getDir(path: string): string","parameters":["path: string"],"documentation":"Returns the parent directory portion of a path.\n\n**Parameters:**\n- **path: string** The path to get the directory from.\n\n**Returns:**\n- string The path with the final part removed (the parent directory).\n\n**Usage:**\n\nGet the directory name of rom/startup.lua\n\n```\n\nfs.getDir(\"rom/startup.lua\")\n\n-- => rom\n\n```"},{"label":"getSize","detail":"getSize(path: string): number","parameters":["path: string"],"documentation":"Returns the size of the specified file.\n\n**Parameters:**\n- **path: string** The file to get the file size of.\n\n**Returns:**\n- number The size of the file, in bytes."},{"label":"exists","detail":"exists(path: string): boolean","parameters":["path: string"],"documentation":"Returns whether the specified path exists.\n\n**Parameters:**\n- **path: string** The path to check the existence of.\n\n**Returns:**\n- boolean Whether the path exists."},{"label":"isDir","detail":"isDir(path: string): boolean","parameters":["path: string"],"documentation":"Returns whether the specified path is a directory.\n\n**Parameters:**\n- **path: string** The path to check.\n\n**Returns:**\n- boolean Whether the path is a directory."},{"label":"isReadOnly","detail":"isReadOnly(path: string): boolean","parameters":["path: string"],"documentation":"Returns whether a path is read-only.\n\n**Parameters:**\n- **path: string** The path to check.\n\n**Returns:**\n- boolean Whether the path cannot be written to."},{"label":"makeDir","detail":"makeDir(path: string): void","parameters":["path: string"],"documentation":"Creates a directory, and any missing parents, at the specified path.\n\n**Parameters:**\n- **path: string** The path to the directory to create."},{"label":"move","detail":"move(path: string, dest: string): void","parameters":["path: string","dest: string"],"documentation":"Moves a file or directory from one path to another.\n\n**Parameters:**\n- **path: string** The current file or directory to move from.\n- **dest: string** The destination path for the file or directory."},{"label":"copy","detail":"copy(path: string, dest: string): void","parameters":["path: string","dest: string"],"documentation":"Copies a file or directory to a new path.\n\n**Parameters:**\n- **path: string** The file or directory to copy.\n- **dest: string** The path to the destination file or directory."},{"label":"delete","detail":"delete(path: string): void","parameters":["path: string"],"documentation":"Deletes a file or directory.\n\n**Parameters:**\n- **path: string** The path to the file or directory to delete."},{"label":"open","detail":"open(path: string, mode: string): table | nil | string","parameters":["path: string","mode: string"],"documentation":"Opens a file for reading or writing at a path.\n\n**Parameters:**\n- **path: string** The path to the file to open.\n- **mode: string** The mode to open the file with.\n\n**Returns:**\n- table A file handle object for the file.\n- nil If the file does not exist, or cannot be opened.\n- string | nil A message explaining why the file cannot be opened.\n\n**Usage:**\n\nRead the contents of a file.\n\n```\n\nlocal file = fs.open(\"/rom/help/intro.txt\", \"r\")\n\nlocal contents = file.readAll()\n\nfile.close()\n\n\n\nprint(contents)\n\nOpen a file and read all lines into a table. io.lines offers an alternative way to do this.\n\nlocal file = fs.open(\"/rom/motd.txt\", \"r\")\n\nlocal lines = {}\n\nwhile true do\n\n  local line = file.readLine()\n\n\n\n  -- If line is nil then we've reached the end of the file and should stop\n\n  if not line then break end\n\n\n\n  lines[#lines + 1] = line\n\nend\n\n\n\nfile.close()\n\n\n\nprint(lines[math.random(#lines)]) -- Pick a random line and print it.\n\nOpen a file and write some text to it. You can run edit out.txt to see the written text.\n\nlocal file = fs.open(\"out.txt\", \"w\")\n\nfile.write(\"Just testing some code\")\n\nfile.close() -- Remember to call close, otherwise changes may not be written!\n\n```"},{"label":"getDrive","detail":"getDrive(path: string): string","parameters":["path: string"],"documentation":"Returns the name of the mount that the specified path is located on.\n\n**Parameters:**\n- **path: string** The path to get the drive of.\n\n**Returns:**\n- string | nil The name of the drive that the file is on; e.g. hdd for local files, or rom for ROM files.\n\n**Usage:**\n\nPrint the drives of a couple of mounts:\n\n```\n\nprint(\"/: \" .. fs.getDrive(\"/\"))\n\nprint(\"/rom/: \" .. fs.getDrive(\"rom\"))\n\n```"},{"label":"getFreeSpace","detail":"getFreeSpace(path: string): number","parameters":["path: string"],"documentation":"Returns the amount of free space available on the drive the path is\nlocated on.\n\n**Parameters:**\n- **path: string** The path to check the free space for.\n\n**Returns:**\n- number | \"unlimited\" The amount of free space available, in bytes, or \"unlimited\"."},{"label":"getCapacity","detail":"getCapacity(path: string): number | treasure","parameters":["path: string"],"documentation":"Returns the capacity of the drive the path is located on.\n\n**Parameters:**\n- **path: string** The path of the drive to get.\n\n**Returns:**\n- number | nil This drive's capacity. This will be nil for \"read-only\" drives, such as the ROM or\n- treasure disks."},{"label":"attributes","detail":"attributes(path: string): {","parameters":["path: string"],"documentation":"Get attributes about a specific file or folder.\n\n**Parameters:**\n- **path: string** The path to get attributes for.\n\n**Returns:**\n- { size = number, isDir = boolean, isReadOnly = boolean, created = number, modified = number } The resulting attributes."},{"label":"ty:ReadWriteHandle:read","detail":"ty:ReadWriteHandle:read(count?: number): nil | number | count | string","parameters":["count?: number"],"documentation":"Read a number of bytes from this file.\n\n**Parameters:**\n- **count?: number** The number of bytes to read. This may be 0 to determine we are at the end of the file. When\nabsent, a single byte will be read.\n\n**Returns:**\n- nil If we are at the end of the file.\n- number The value of the byte read. This is returned if the file is opened in binary mode and\n- count is absent\n- string The bytes read as a string. This is returned when the count is given."},{"label":"ty:ReadWriteHandle:readAll","detail":"ty:ReadWriteHandle:readAll(): string","parameters":[],"documentation":"Read the remainder of the file.\n\n**Returns:**\n- string | nil The remaining contents of the file, or nil in the event of an error."},{"label":"ty:ReadWriteHandle:readLine","detail":"ty:ReadWriteHandle:readLine(withTrailing?: boolean): string","parameters":["withTrailing?: boolean"],"documentation":"Read a line from the file.\n\n**Parameters:**\n- **withTrailing?: boolean** Whether to include the newline characters with the returned string. Defaults to false.\n\n**Returns:**\n- string | nil The read line or nil if at the end of the file."},{"label":"ty:ReadWriteHandle:seek","detail":"ty:ReadWriteHandle:seek(whence?: string, offset?: number): number | nil | string","parameters":["whence?: string","offset?: number"],"documentation":"Seek to a new position within the file, changing where bytes are written to. The new position is an offset\ngiven by offset, relative to a start position determined by whence:\n\n**Parameters:**\n- **whence?: string** Where the offset is relative to.\n- **offset?: number** The offset to seek to.\n\n**Returns:**\n- number The new position.\n- nil If seeking failed.\n- string The reason seeking failed."},{"label":"ty:ReadWriteHandle:write","detail":"ty:ReadWriteHandle:write(contents: string, charcode: number): void","parameters":["contents: string","charcode: number"],"documentation":"Write a string or byte to the file.\n\n**Parameters:**\n- **contents: string** The string to write.\n- **charcode: number** The byte to write, if the file was opened in binary mode."},{"label":"ty:ReadWriteHandle:writeLine","detail":"ty:ReadWriteHandle:writeLine(text: string): void","parameters":["text: string"],"documentation":"Write a string of characters to the file, following them with a new line character.\n\n**Parameters:**\n- **text: string** The text to write to the file."},{"label":"ty:ReadWriteHandle:flush","detail":"ty:ReadWriteHandle:flush(): void","parameters":[],"documentation":"Save the current file without closing it."},{"label":"ty:ReadWriteHandle:close","detail":"ty:ReadWriteHandle:close(): void","parameters":[],"documentation":"Close this file, freeing any resources it uses."},{"label":"ty:WriteHandle:write","detail":"ty:WriteHandle:write(contents: string, charcode: number): void","parameters":["contents: string","charcode: number"],"documentation":"Write a string or byte to the file.\n\n**Parameters:**\n- **contents: string** The string to write.\n- **charcode: number** The byte to write, if the file was opened in binary mode."},{"label":"ty:WriteHandle:writeLine","detail":"ty:WriteHandle:writeLine(text: string): void","parameters":["text: string"],"documentation":"Write a string of characters to the file, following them with a new line character.\n\n**Parameters:**\n- **text: string** The text to write to the file."},{"label":"ty:WriteHandle:flush","detail":"ty:WriteHandle:flush(): void","parameters":[],"documentation":"Save the current file without closing it."},{"label":"ty:WriteHandle:seek","detail":"ty:WriteHandle:seek(whence?: string, offset?: number): number | nil | string","parameters":["whence?: string","offset?: number"],"documentation":"Seek to a new position within the file, changing where bytes are written to. The new position is an offset\ngiven by offset, relative to a start position determined by whence:\n\n**Parameters:**\n- **whence?: string** Where the offset is relative to.\n- **offset?: number** The offset to seek to.\n\n**Returns:**\n- number The new position.\n- nil If seeking failed.\n- string The reason seeking failed."},{"label":"ty:WriteHandle:close","detail":"ty:WriteHandle:close(): void","parameters":[],"documentation":"Close this file, freeing any resources it uses."},{"label":"ty:ReadHandle:read","detail":"ty:ReadHandle:read(count?: number): nil | number | count | string","parameters":["count?: number"],"documentation":"Read a number of bytes from this file.\n\n**Parameters:**\n- **count?: number** The number of bytes to read. This may be 0 to determine we are at the end of the file. When\nabsent, a single byte will be read.\n\n**Returns:**\n- nil If we are at the end of the file.\n- number The value of the byte read. This is returned if the file is opened in binary mode and\n- count is absent\n- string The bytes read as a string. This is returned when the count is given."},{"label":"ty:ReadHandle:readAll","detail":"ty:ReadHandle:readAll(): string","parameters":[],"documentation":"Read the remainder of the file.\n\n**Returns:**\n- string | nil The remaining contents of the file, or nil in the event of an error."},{"label":"ty:ReadHandle:readLine","detail":"ty:ReadHandle:readLine(withTrailing?: boolean): string","parameters":["withTrailing?: boolean"],"documentation":"Read a line from the file.\n\n**Parameters:**\n- **withTrailing?: boolean** Whether to include the newline characters with the returned string. Defaults to false.\n\n**Returns:**\n- string | nil The read line or nil if at the end of the file."},{"label":"ty:ReadHandle:seek","detail":"ty:ReadHandle:seek(whence?: string, offset?: number): number | nil | string","parameters":["whence?: string","offset?: number"],"documentation":"Seek to a new position within the file, changing where bytes are written to. The new position is an offset\ngiven by offset, relative to a start position determined by whence:\n\n**Parameters:**\n- **whence?: string** Where the offset is relative to.\n- **offset?: number** The offset to seek to.\n\n**Returns:**\n- number The new position.\n- nil If seeking failed.\n- string The reason seeking failed."},{"label":"ty:ReadHandle:close","detail":"ty:ReadHandle:close(): void","parameters":[],"documentation":"Close this file, freeing any resources it uses."}];
  }
}
